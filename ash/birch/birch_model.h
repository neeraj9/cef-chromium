// Copyright 2023 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#ifndef ASH_BIRCH_BIRCH_MODEL_H_
#define ASH_BIRCH_BIRCH_MODEL_H_

#include <map>
#include <optional>
#include <vector>

#include "ash/ash_export.h"
#include "ash/birch/birch_client.h"
#include "ash/birch/birch_item.h"
#include "base/timer/timer.h"

namespace ash {

// Birch model, which is used to aggregate and store relevant information from
// different providers.
class ASH_EXPORT BirchModel {
 public:
  BirchModel();
  BirchModel(const BirchModel&) = delete;
  BirchModel& operator=(const BirchModel&) = delete;
  ~BirchModel();

  // Sends a request to the birch keyed service to fetch data into the model.
  // `callback` will run once either all data is fresh or the request timeout
  // has expired.
  void RequestBirchDataFetch(base::OnceClosure callback);

  void SetCalendarItems(std::vector<BirchCalendarItem> calendar_items);
  void SetFileSuggestItems(std::vector<BirchFileItem> file_suggest_items);
  void SetRecentTabItems(std::vector<BirchTabItem> recent_tab_items);
  void SetWeatherItems(std::vector<BirchWeatherItem> weather_items);

  void SetClient(BirchClient* client) { birch_client_ = client; }

  const std::vector<BirchCalendarItem>& GetCalendarItemsForTest() const {
    return calendar_items_;
  }
  const std::vector<BirchFileItem>& GetFileSuggestItemsForTest() const {
    return file_suggest_items_;
  }
  const std::vector<BirchTabItem>& GetTabsForTest() const {
    return recent_tab_items_;
  }
  const std::vector<BirchWeatherItem>& GetWeatherForTest() const {
    return weather_items_;
  }

  std::vector<std::unique_ptr<BirchItem>> GetAllItems() const;

  // Returns whether all data in the model is currently fresh.
  bool IsDataFresh();

  void OverrideWeatherProviderForTest(
      std::unique_ptr<BirchClient> weather_provider);

 private:
  // Timer and callback for a pending data fetch request.
  // The callback will be run if the timer expires before all data is fetched.
  struct PendingRequest {
    PendingRequest();
    ~PendingRequest();

    base::OnceClosure callback;
    std::unique_ptr<base::OneShotTimer> timer;
  };

  // Called when a pending data fetch request timeout expires.
  void HandleRequestTimeout(size_t request_id);

  // Runs data fetch callbacks after a data fetch request when all data items
  // have been refreshed.
  void MaybeRespondToDataFetchRequest();

  // Whether the calendar event data is freshly fetched.
  bool is_calendar_data_fresh_ = false;

  // Whether the current files data is freshly fetched.
  bool is_files_data_fresh_ = false;

  // Whether the current tabs data is freshly fetched.
  bool is_tabs_data_fresh_ = false;

  // Whether the current weather data is freshly fetched.
  // TODO(323229328): Use a timestamp to determine if weather is fresh.
  bool is_weather_data_fresh_ = false;

  size_t next_request_id_ = 0u;
  // Pending data fetched requests mapped by their request IDs. IDs are
  // generated by incrementing `next_request_id_`.
  std::map<size_t, PendingRequest> pending_requests_;

  // A type-specific list of calendar event items.
  std::vector<BirchCalendarItem> calendar_items_;

  // A type-specific list of items for all file suggestion items.
  std::vector<BirchFileItem> file_suggest_items_;

  // A type-specific list of items for all tab items.
  std::vector<BirchTabItem> recent_tab_items_;

  // A type-specific list of weather items.
  std::vector<BirchWeatherItem> weather_items_;

  raw_ptr<BirchClient> birch_client_ = nullptr;

  std::unique_ptr<BirchClient> weather_provider_;
};

}  // namespace ash

#endif  // ASH_BIRCH_BIRCH_MODEL_H_
