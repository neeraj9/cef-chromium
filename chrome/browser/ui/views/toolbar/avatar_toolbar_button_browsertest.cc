// Copyright 2021 The Chromium Authors
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.

#include <optional>

#include "base/functional/callback_helpers.h"
#include "base/test/scoped_feature_list.h"
#include "base/test/with_feature_override.h"
#include "chrome/browser/browser_process.h"
#include "chrome/browser/enterprise/util/managed_browser_utils.h"
#include "chrome/browser/profiles/keep_alive/profile_keep_alive_types.h"
#include "chrome/browser/profiles/keep_alive/scoped_profile_keep_alive.h"
#include "chrome/browser/profiles/profile.h"
#include "chrome/browser/profiles/profile_attributes_entry.h"
#include "chrome/browser/profiles/profile_attributes_storage.h"
#include "chrome/browser/profiles/profile_manager.h"
#include "chrome/browser/themes/theme_service.h"
#include "chrome/browser/themes/theme_service_factory.h"
#include "chrome/browser/ui/browser.h"
#include "chrome/browser/ui/profiles/profile_colors_util.h"
#include "chrome/browser/ui/ui_features.h"
#include "chrome/browser/ui/views/frame/browser_view.h"
#include "chrome/browser/ui/views/toolbar/toolbar_view.h"
#include "chrome/test/base/in_process_browser_test.h"
#include "components/keep_alive_registry/keep_alive_types.h"
#include "components/keep_alive_registry/scoped_keep_alive.h"
#include "content/public/test/browser_test.h"
#include "testing/gtest/include/gtest/gtest.h"
#include "third_party/skia/include/core/SkColor.h"
#include "ui/base/mojom/themes.mojom.h"
#include "ui/base/ui_base_features.h"

namespace {
ui::mojom::BrowserColorVariant kColorVariant =
    ui::mojom::BrowserColorVariant::kTonalSpot;

enum class ColorThemeType { kAutogeneratedTheme, kUserColor };
}  // namespace

class AvatarToolbarButtonBrowserTest : public InProcessBrowserTest {
 public:
  AvatarToolbarButtonBrowserTest() = default;
  AvatarToolbarButtonBrowserTest(const AvatarToolbarButtonBrowserTest&) =
      delete;
  AvatarToolbarButtonBrowserTest& operator=(
      const AvatarToolbarButtonBrowserTest&) = delete;
  ~AvatarToolbarButtonBrowserTest() override = default;

  AvatarToolbarButton* GetAvatarToolbarButton(Browser* browser) {
    return BrowserView::GetBrowserViewForBrowser(browser)->toolbar()->avatar_;
  }

  // Returns the window count in avatar button text, if it exists.
  std::optional<int> GetWindowCountInAvatarButtonText(Browser* browser) {
    std::u16string button_text = GetAvatarToolbarButton(browser)->GetText();

    size_t before_number = button_text.find('(');
    if (before_number == std::string::npos)
      return std::optional<int>();

    size_t after_number = button_text.find(')');
    EXPECT_NE(std::string::npos, after_number);

    std::u16string number_text =
        button_text.substr(before_number + 1, after_number - before_number - 1);
    int window_count;
    return base::StringToInt(number_text, &window_count)
               ? std::optional<int>(window_count)
               : std::optional<int>();
  }
};

IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonBrowserTest, IncognitoWindowCount) {
  Profile* profile = browser()->profile();
  Browser* browser1 = CreateIncognitoBrowser(profile);
  EXPECT_FALSE(GetWindowCountInAvatarButtonText(browser1).has_value());

  Browser* browser2 = CreateIncognitoBrowser(profile);
  EXPECT_EQ(2, *GetWindowCountInAvatarButtonText(browser1));
  EXPECT_EQ(2, *GetWindowCountInAvatarButtonText(browser2));

  CloseBrowserSynchronously(browser2);
  EXPECT_FALSE(GetWindowCountInAvatarButtonText(browser1).has_value());
}

// TODO(https://crbug.com/1179717): Enable the test for ChromeOS.
// Note that |CreateGuestBrowser| does not create a Guest browser for ChromeOS
// and Chrome OS Guest does not have window counter.
#if !BUILDFLAG(IS_CHROMEOS_ASH)
IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonBrowserTest, GuestWindowCount) {
  Browser* browser1 = CreateGuestBrowser();
  EXPECT_FALSE(GetWindowCountInAvatarButtonText(browser1).has_value());

  Browser* browser2 = CreateGuestBrowser();
  EXPECT_EQ(2, *GetWindowCountInAvatarButtonText(browser1));
  EXPECT_EQ(2, *GetWindowCountInAvatarButtonText(browser2));

  CloseBrowserSynchronously(browser2);
  EXPECT_FALSE(GetWindowCountInAvatarButtonText(browser1).has_value());
}
#endif

IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonBrowserTest, DefaultBrowser) {
  AvatarToolbarButton* avatar = GetAvatarToolbarButton(browser());
  ASSERT_TRUE(avatar);
#if BUILDFLAG(IS_CHROMEOS_ASH)
  // No avatar button is shown in normal Ash windows.
  EXPECT_FALSE(avatar->GetVisible());
#else
  EXPECT_TRUE(avatar->GetVisible());
  EXPECT_TRUE(avatar->GetEnabled());
#endif
}

IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonBrowserTest, IncognitoBrowser) {
  Browser* browser1 = CreateIncognitoBrowser(browser()->profile());
  AvatarToolbarButton* avatar = GetAvatarToolbarButton(browser1);
  ASSERT_TRUE(avatar);
  // Incognito browsers always show an enabled avatar button.
  EXPECT_TRUE(avatar->GetVisible());
  EXPECT_TRUE(avatar->GetEnabled());
}

#if BUILDFLAG(IS_CHROMEOS)
IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonBrowserTest, SigninBrowser) {
  // Create an Incognito browser first.
  CreateIncognitoBrowser(browser()->profile());
  // Create a portal signin browser which will not be the Incognito browser.
  Profile::OTRProfileID profile_id(
      Profile::OTRProfileID::CreateUniqueForCaptivePortal());
  Browser* browser1 = Browser::Create(Browser::CreateParams(
      browser()->profile()->GetOffTheRecordProfile(profile_id,
                                                   /*create_if_needed=*/true),
      true));
  AddBlankTabAndShow(browser1);
  AvatarToolbarButton* avatar = GetAvatarToolbarButton(browser1);
  ASSERT_TRUE(avatar);
  // On ChromeOS (Ash and Lacros), captive portal signin windows show a
  // disabled avatar button to indicate that the window is incognito.
  EXPECT_TRUE(avatar->GetVisible());
  EXPECT_FALSE(avatar->GetEnabled());
}
#endif

IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonBrowserTest,
                       ShowExplicitTextAndHide) {
  AvatarToolbarButton* avatar = GetAvatarToolbarButton(browser());
  ASSERT_EQ(avatar->GetText(), std::u16string());

  std::u16string new_text(u"Some New Text");
  base::ScopedClosureRunner hide_callback = avatar->ShowExplicitText(new_text);

  EXPECT_EQ(avatar->GetText(), new_text);
  hide_callback.RunAndReset();
  EXPECT_EQ(avatar->GetText(), std::u16string());
}

IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonBrowserTest,
                       ShowExplicitTextAndDefaultHide) {
  AvatarToolbarButton* avatar = GetAvatarToolbarButton(browser());
  ASSERT_EQ(avatar->GetText(), std::u16string());

  // Simulates a stack that enforces the change of text, but never explicitly
  // call the hide callback. It should still be done on explicitly destroying
  // the caller.
  {
    std::u16string new_text(u"Some New Text");
    base::ScopedClosureRunner hide_callback =
        avatar->ShowExplicitText(new_text);
    EXPECT_EQ(avatar->GetText(), new_text);
  }

  EXPECT_EQ(avatar->GetText(), std::u16string());
}

IN_PROC_BROWSER_TEST_F(AvatarToolbarButtonBrowserTest,
                       ShowExplicitTextTwiceAndHide) {
  AvatarToolbarButton* avatar = GetAvatarToolbarButton(browser());
  ASSERT_EQ(avatar->GetText(), std::u16string());

  std::u16string initial_new_text(u"Some New Text");
  base::ScopedClosureRunner initial_hide_callback =
      avatar->ShowExplicitText(initial_new_text);

  EXPECT_EQ(avatar->GetText(), initial_new_text);

  std::u16string override_new_text(u"Some New Override Text");
  base::ScopedClosureRunner override_hide_callback =
      avatar->ShowExplicitText(override_new_text);

  EXPECT_EQ(avatar->GetText(), override_new_text);

  // Attempting to reset the initial text should have no effect.
  initial_hide_callback.RunAndReset();
  EXPECT_EQ(avatar->GetText(), override_new_text);

  // Resetting the last text should work fine.
  override_hide_callback.RunAndReset();
  EXPECT_EQ(avatar->GetText(), std::u16string());
}

// Test suite for testing `AvatarToolbarButton`'s responsibility of updating
// color information in `ProfileAttributesStorage`.
class AvatarToolbarButtonProfileColorBrowserTest
    : public AvatarToolbarButtonBrowserTest,
      public testing::WithParamInterface<ColorThemeType> {
 public:
  AvatarToolbarButtonProfileColorBrowserTest() {
    std::vector<base::test::FeatureRef> chrome_refresh_features = {
        features::kChromeRefresh2023, features::kChromeWebuiRefresh2023};
    if (GetParam() == ColorThemeType::kUserColor) {
      scoped_feature_list_.InitWithFeatures(
          /*enabled_features=*/chrome_refresh_features,
          /*disabled_features=*/{});
    } else {
      scoped_feature_list_.InitWithFeatures(
          /*enabled_features=*/{},
          /*disabled_features=*/chrome_refresh_features);
    }
  }

  void SetUpOnMainThread() override {
    AvatarToolbarButtonBrowserTest::SetUpOnMainThread();
    theme_service(browser()->profile())
        ->SetBrowserColorScheme(ThemeService::BrowserColorScheme::kLight);
  }

  ProfileAttributesEntry* GetProfileAttributesEntry(Profile* profile) {
    ProfileAttributesEntry* entry =
        g_browser_process->profile_manager()
            ->GetProfileAttributesStorage()
            .GetProfileAttributesWithPath(profile->GetPath());
    CHECK(entry);
    return entry;
  }

  void SetColorTheme(Profile* profile, SkColor color) {
    ThemeService* service = theme_service(profile);
    switch (GetParam()) {
      case ColorThemeType::kAutogeneratedTheme:
        service->BuildAutogeneratedThemeFromColor(color);
        break;
      case ColorThemeType::kUserColor:
        service->SetUserColorAndBrowserColorVariant(color, kColorVariant);
        service->UseDeviceTheme(false);
        break;
    }
  }

  void SetDefaultTheme(Profile* profile) {
    ThemeService* service = theme_service(profile);
    switch (GetParam()) {
      case ColorThemeType::kAutogeneratedTheme:
        service->UseDefaultTheme();
        break;
      case ColorThemeType::kUserColor:
        service->SetUserColorAndBrowserColorVariant(SK_ColorTRANSPARENT,
                                                    kColorVariant);
        service->UseDeviceTheme(false);
        break;
    }
  }

  ThemeService* theme_service(Profile* profile) {
    return ThemeServiceFactory::GetForProfile(profile);
  }

 private:
  base::test::ScopedFeatureList scoped_feature_list_;
};

// Tests that the profile theme colors are updated when an autogenerated theme
// is set up.
IN_PROC_BROWSER_TEST_P(AvatarToolbarButtonProfileColorBrowserTest,
                       PRE_AutogeneratedTheme) {
  Profile* profile = browser()->profile();
  ProfileAttributesEntry* entry = GetProfileAttributesEntry(profile);
  EXPECT_EQ(entry->GetProfileThemeColors(), GetDefaultProfileThemeColors());

  SetColorTheme(profile, SK_ColorGREEN);
  ProfileThemeColors theme_colors = entry->GetProfileThemeColors();
  EXPECT_NE(theme_colors, GetDefaultProfileThemeColors());

  // Check that a switch to another autogenerated theme updates the colors.
  SetColorTheme(profile, SK_ColorMAGENTA);
  ProfileThemeColors theme_colors2 = entry->GetProfileThemeColors();
  EXPECT_NE(theme_colors, theme_colors2);
  EXPECT_NE(theme_colors, GetDefaultProfileThemeColors());

  // Reset the cached colors to test that they're recreated on the next startup.
  entry->SetProfileThemeColors(std::nullopt);
  EXPECT_EQ(entry->GetProfileThemeColors(), GetDefaultProfileThemeColors());
}

// Tests that the profile theme colors are updated on startup.
IN_PROC_BROWSER_TEST_P(AvatarToolbarButtonProfileColorBrowserTest,
                       AutogeneratedTheme) {
  EXPECT_NE(
      GetProfileAttributesEntry(browser()->profile())->GetProfileThemeColors(),
      GetDefaultProfileThemeColors());
}

// Tests that switching to the default theme resets the colors.
IN_PROC_BROWSER_TEST_P(AvatarToolbarButtonProfileColorBrowserTest,
                       DefaultTheme) {
  Profile* profile = browser()->profile();
  SetColorTheme(profile, SK_ColorGREEN);
  EXPECT_NE(GetProfileAttributesEntry(profile)->GetProfileThemeColors(),
            GetDefaultProfileThemeColors());

  SetDefaultTheme(profile);
  EXPECT_EQ(GetProfileAttributesEntry(profile)->GetProfileThemeColors(),
            GetDefaultProfileThemeColors());
}

// Tests that a theme is updated after opening a browser.
IN_PROC_BROWSER_TEST_P(AvatarToolbarButtonProfileColorBrowserTest,
                       UpdateThemeOnBrowserUpdate) {
  Profile* profile = browser()->profile();
  // Keeps the browser process and the profile alive while a browser window is
  // closed.
  ScopedKeepAlive keep_alive(KeepAliveOrigin::BROWSER,
                             KeepAliveRestartOption::DISABLED);
  ScopedProfileKeepAlive profile_keep_alive(
      profile, ProfileKeepAliveOrigin::kBackgroundMode);
  CloseBrowserSynchronously(browser());

  SetColorTheme(profile, SK_ColorGREEN);
  // Colors haven't been changed yet because the profile has no active browsers.
  EXPECT_EQ(GetProfileAttributesEntry(profile)->GetProfileThemeColors(),
            GetDefaultProfileThemeColors());

  CreateBrowser(profile);
  EXPECT_NE(GetProfileAttributesEntry(profile)->GetProfileThemeColors(),
            GetDefaultProfileThemeColors());
}

INSTANTIATE_TEST_SUITE_P(,
                         AvatarToolbarButtonProfileColorBrowserTest,
                         testing::Values(ColorThemeType::kAutogeneratedTheme,
                                         ColorThemeType::kUserColor),
                         [](const auto& info) {
                           switch (info.param) {
                             case ColorThemeType::kAutogeneratedTheme:
                               return "AutogeneratedTheme";
                             case ColorThemeType::kUserColor:
                               return "UserColor";
                           }
                         });

// Test suite for testing `AvatarToolbarButton`'s responsibility of updating
// color information in `ProfileAttributesStorage`.
class AvatarToolbarButtonEnterpriseBadgingBrowserTest
    : public AvatarToolbarButtonBrowserTest,
      public base::test::WithFeatureOverride {
 public:
  AvatarToolbarButtonEnterpriseBadgingBrowserTest()
      : base::test::WithFeatureOverride(features::kEnterpriseProfileBadging) {}
};

IN_PROC_BROWSER_TEST_P(AvatarToolbarButtonEnterpriseBadgingBrowserTest,
                       WorkProfileTextBadging) {
  AvatarToolbarButton* toolbar_button = GetAvatarToolbarButton(browser());
  EXPECT_TRUE(toolbar_button->GetText().empty());
  chrome::enterprise_util::SetUserAcceptedAccountManagement(
      browser()->profile(), true);
  std::u16string work_label = u"Work";
  if (base::FeatureList::IsEnabled(features::kEnterpriseProfileBadging)) {
#if BUILDFLAG(ENABLE_DICE_SUPPORT)
    EXPECT_EQ(toolbar_button->GetText(), work_label);
    auto clear_closure = toolbar_button->ShowExplicitText(u"Explicit text");
    EXPECT_NE(toolbar_button->GetText(), work_label);
    clear_closure.RunAndReset();
    EXPECT_EQ(toolbar_button->GetText(), work_label);
#else
    EXPECT_NE(toolbar_button->GetText(), work_label);
#endif
  } else {
    EXPECT_NE(toolbar_button->GetText(), work_label);
#if BUILDFLAG(ENABLE_DICE_SUPPORT)
    auto clear_closure = toolbar_button->ShowExplicitText(u"Explicit text");
    EXPECT_NE(toolbar_button->GetText(), work_label);
    clear_closure.RunAndReset();
    EXPECT_NE(toolbar_button->GetText(), work_label);
#endif
  }
}

INSTANTIATE_FEATURE_OVERRIDE_TEST_SUITE(
    AvatarToolbarButtonEnterpriseBadgingBrowserTest);
